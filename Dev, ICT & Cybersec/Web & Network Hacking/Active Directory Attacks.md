Before talking about AD Attacks if fundamental having a good knowledge about the basic working of [Active Directory 101](../Dev,%20scripting%20&%20OS/Active%20Directory%20101.md). The final goal is to advance our privilege level until we gain control of one or more domains.

## Basic concepts

Within AD, **administrators use groups to assign permissions** to member users, which means that during our assessment, we would **target high-value groups**. In this case, we could compromise a member of the Domain Admins group to gain complete control of every single computer in the domain.
Another way to gain control of a domain is to successfully **compromise a domain controller** since it may be used to **modify all domain-joined computers** or **execute applications** on them. Additionally, as we will see later, the domain controller **contains all the password hashes** of every single domain user account.

## Active Directory Enumeration

Typically, an attack against Active Directory infrastructure begins with a successful exploit or client-side attack against either a domain workstation or server followed by the [Active Directory Enumeration](Active%20Directory%20Enumeration.md).

---

# Active Directory Common Attacks

## Cached Credential Storage and Retrieval

Since Microsoft’s implementation of [Kerberos](../Services/Kerberos.md) makes use of single sign-on, password hashes must be stored somewhere in order to renew a TGT request. In current versions of Windows, these hashes are stored in the Local Security Authority Subsystem Service (LSASS) memory space.
There are two main approached in order to retrieve important data useful to compromise the AD:

- [Dumping domain user from LSASS](../Tools/mimikatz.md#Dumping%20domain%20user%20from%20LSASS):
	if we gain access to these hashes, we could crack them to obtain the cleartext password or reuse them to perform various actions.
- [Dumping tickets from LSASS](../Tools/mimikatz.md#Dumping%20tickets%20from%20LSASS):
	exploit Kerberos authentication by abusing TGT and service tickets. As already discussed, we know that Kerberos TGT and service tickets for users currently logged on to the local machine are stored for future use. These tickets are also stored in LSASS and we can use [mimikatz](../Tools/mimikatz.md) to interact with and retrieve our own tickets and the tickets of other local users.

## Service Account Attacks (Kerberoasting [^1])

[^1]: https://github.com/nidem/kerberoast

Recalling the explanation of the [Kerberos Authentication](../Dev,%20scripting%20&%20OS/Active%20Directory%20101.md#Kerberos%20Authentication) protocol, we know that when the user wants to access a resource hosted by a SPN, the client requests a service ticket that is generated by the domain controller. The service ticket is then decrypted and validated by the application server, since it is encrypted through the password hash of the SPN.

>[!tip]
>When requesting the service ticket from the domain controller, no checks are performed on whether the user has any permissions to access the service hosted by the service principal name. These checks are performed as a second step only when connecting to the service itself. This means that if we know the SPN we want to target, we can request a service ticket for it from the domain controller. Then, since it is our own ticket, we can extract it from local memory and save it to disk.

Requesting the service ticket:

```powershell
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList 'HTTP/CorpWebServer.corp.com'
```

Once requested the ticket, it is possible to dump it using:

- [mimikatz](../Tools/mimikatz.md#Exporting%20Kerberos%20Tickets)
- [Dumping Kerberos Tickets with klist](../Dev,%20scripting%20&%20OS/Powershell%20for%20pentesters.md#Dumping%20Kerberos%20Tickets%20(klist))
- [Invoke-Kerberoast.ps1](../Tools/Empire.md#Invoke-Kerberoast.ps1)
- [GetUserSPNs](../Tools/impacket.md#GetUserSPNs) (If it is not possible to get access to the machine but valid credentials are known)

and then [cracking it ](Password%20Attacks.md#Cracking%20Hashes) (converting it with [kirbi2john](../Tools/john.md#External%20scripts)) though the usage of

- [john](../Tools/john.md)
- [hashcat](../Tools/hashcat.md#Kerberoasting)
- [tgsrepcrack.py](https://github.com/nidem/kerberoast)
    
    ```
    kali@kali:~$ sudo apt update && sudo apt install kerberoast
    ...
    kali@kali:~$ python /usr/share/kerberoast/tgsrepcrack.py wordlist.txt 1-40a50000-Offsec@HTTP~CorpWebServer.corp.com-CORP.COM.kirbi
    found password for ticket 0: Qwerty09! File: 1-40a50000-Offsec@HTTP~CorpWebServer.corp.com-CORP.COM.kirbi
    All tickets cracked!
    
    ```
    

## AS-REP Roasting

>[!tip]
>By default pre-authentication against Domain Controller is enabled for every user. If one or more users have it disabled, it is possible to intercept and try to crack the AS-REP response from the KDC, obtaining the user hash and next cracking it.

```bash
kali@kali:~$ GetNPUsers.py domain.local/user
```

Tools:

- [PowerView.ps1](../Tools/Empire.md#PowerView.ps1) (enumerating users)
- [AS-REP Roasting](../Tools/impacket.md#AS-REP%20Roasting)

## Low and Slow Password Guessing

When performing a brute-force or wordlist authentication attack, we must be aware of account lockouts since too many failed logins may block the account for further attacks and possibly alert system administrators.

```powershell
PS C:\Users\Offsec.corp> net accounts
Force user logoff how long after time expires?: Never
Minimum password age (days): 0
Maximum password age (days): 42
Minimum password length: 0
Length of password history maintained: None
Lockout threshold: 5
Lockout duration (minutes): 30
Lockout observation window (minutes): 30
Computer role: WORKSTATION
The command completed successfully
```

Lockout threshold: 5 login attempts before lockout
Lockout observation: after 30 minutes after the last failed login, we are able to make another attempt.
TOT: 192 logins in a twenty-four-hour

In order to perform this attack it is possible to use the [DirectoryEntry](../Dev,%20scripting%20&%20OS/Powershell%20for%20pentesters.md#Low%20and%20Slow%20Password%20Guessing) Powershell constructor.

---

# Active Directory Lateral Movement

We will explore an alternative lateral movement technique that will allow us to authenticate to a system and gain code execution using only a user’s hash or a Kerberos ticket.

## Pass the Hash (NTLM)

The [Pass the hash](Password%20Attacks.md#Passing%20the%20hash) (PtH) technique allows an attacker to authenticate to a remote system or service using a **user’s NTLM hash** instead of the associated plaintext password.

## Overpass the Hash (NTLM —> TGT)

With overpass the hash, we can “over” abuse a NTLM user hash to **gain a full Kerberos Ticket Granting Ticket** (TGT) or **service ticket**, which grants us access to another machine or service as that user.

>[!warning]
>As with Pass the Hash, Overpass the Hash also requires access to the special admin share called Admin$ , which in turn requires local administrative rights on the target machine.

As fist step it is necessary to [dump local user from LSASS](../Tools/mimikatz.md#Dumping%20local%20user%20from%20LSASS). The essence of the overpass the hash technique is to **turn the NTLM hash into a Kerberos ticket** and avoid the use of NTLM authentication.

A simple way to do this is with the `sekurlsa::pth` [^2] command, from [mimikatz](../Tools/mimikatz.md). 

[^2]: [Overpass the Hash (NTLM —> Kerberos)](../Tools/mimikatz.md#Overpass%20the%20Hash%20(NTLM%20—>%20Kerberos))

At this point, we have a new PowerShell session that allows us to execute commands as Jeff_Admin

```powershell
PS C:\Windows\system32> klist
Current LogonId is 0:0x1583ae
Cached Tickets: (0)
```

No Kerberos tickets have been cached, but this is expected since Jeff_Admin has not performed an interactive login. However, let’s generate a TGT by authenticating to a network share on the domain controller with net use:

```powershell
PS C:\Windows\system32> net use \\dc01
The command completed successfully.

PS C:\Windows\system32> klist
Current LogonId is 0:0x1583ae
Cached Tickets: (3)

#0> Client: jeff_admin @ CORP.COM
	Server: krbtgt/CORP.COM @ CORP.COM
	KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
	Ticket Flags 0x60a10000 -> forwardable forwarded renewable pre_authent name_canoni
	Start Time: 2/12/2018 13:59:40 (local)
	End Time: 2/12/2018 23:59:40 (local)
	Renew Time: 2/19/2018 13:59:40 (local)
	Session Key Type: AES-256-CTS-HMAC-SHA1-96
	Cache Flags: 0x2 -> DELEGATION
	Kdc Called: DC01.corp.com
#1> Client: jeff_admin @ CORP.COM
	Server: krbtgt/CORP.COM @ CORP.COM
	KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
...
```

We have now converted our NTLM hash into a Kerberos TGT, allowing us to use any tools that rely on Kerberos authentication (as opposed to NTLM) such as the official [PsExec](../Tools/Sysinternals%20Suite.md#PsExec) application from Microsoft.
Since we have generated Kerberos tickets and operate in the context of Jeff_Admin in the PowerShell session, we may reuse the TGT to obtain code execution on the domain controller.

```powershell
PS C:\Tools\active_directory> .\PsExec.exe \\dc01 cmd.exe
PsExec v2.2 - Execute processes remotely
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

C:\Windows\system32> ipconfig
Windows IP Configuration
Ethernet adapter Ethernet0:
Connection-specific DNS Suffix . :
Link-local IPv6 Address . . . . . : fe80::7959:aaad:eec:3969%2
IPv4 Address. . . . . . . . . . . : 192.168.1.110
Subnet Mask . . . . . . . . . . . : 255.255.255.0
Default Gateway . . . . . . . . . : 192.168.1.1
...

C:\Windows\system32> whoami
corp\jeff_admin
```

## Pass the Ticket (Silver Ticket)

The Pass the Ticket attack takes advantage of the TGS, which may be exported and re-injected elsewhere on the network and then used to authenticate to a specific service.
In addition, if the service tickets belong to the current user, then no administrative privileges are required.

Previously, we demonstrated that we could crack the service account password hash and obtain the password from the service ticket. This password could then be used to access resources available to the service account.

However, if the service account is not a local administrator on any servers, we would not be able to perform lateral movement using vectors
such as pass the hash or overpass the hash and therefore, in these cases, we would need to use a different approach.

>[!tip]
>Remembering the inner workings of the Kerberos authentication, the application on the server executing in the context of the service account checks the user’s permissions from the group memberships included in the service ticket. The application blindly trusts the integrity of the service ticket since it is encrypted with a password hash - in theory - only known to the service account and the domain controller.

With the service account password or its associated NTLM hash at hand, **we can forge our own service ticket** to access the target resource **with any permissions we desire**. This custom-created ticket is known as a [silver ticket](https://adsecurity.org/?p=2011).
If the service principal name is used on multiple servers, the silver ticket can be leveraged against them all.

[mimikatz](../Tools/mimikatz.md) can craft a silver ticket and inject it straight into memory through the `kerberos::golden` command [^3].

[^3]: [Craft a Silver Ticket](../Tools/mimikatz.md#Craft%20a%20Silver%20Ticket)

After the attack a new service ticket for the SPN has been loaded into memory and [mimikatz](../Tools/mimikatz.md) set appropriate group membership permissions in the forged ticket. From the perspective of the application, the current user will be both the built-in local administrator and a member of several highly-privileged groups, including the Domain Admins group.
Now that we have this ticket loaded into memory, we can interact with the service and gain access to any information based on the group memberships we put in the silver ticket. Depending on the type of service, it might also be possible to obtain code execution.

## Distributed Component Object Model

The Microsoft Component Object Model (COM) is a system for creating software components that interact with each other.
While COM was created for either same-process or cross-process interaction, it was extended to Distributed Component Object Model (DCOM) for interaction between multiple computers over a network.

Both COM and DCOM are very old technologies dating back to the very first editions of Windows.
Interaction with DCOM is performed over RPC on TCP port 135 and local administrator access is required to call the DCOM Service Control Manager, which is essentially an API.
DCOM objects related to Microsoft Office allow lateral movement, both through the use of Outlook 685 as well as PowerPoint.
Since this requires the presence of Microsoft Office on the target computer, this lateral movement technique is best leveraged against workstations.

Specifically, we will leverage the Excel.Application DCOM object.

```powershell
$com = [activator]::CreateInstance([type]::GetTypeFromProgId("Excel.Application", "192.168.1.110"))
$LocalPath = "C:\Users\jeff_admin.corp\myexcel.xls"
$RemotePath = "\\192.168.1.110\c$\myexcel.xls"
[System.IO.File]::Copy($LocalPath, $RemotePath, $True)
$Path = "\\192.168.1.110\c$\Windows\sysWOW64\config\systemprofile\Desktop"
$temp = [system.io.directory]::createDirectory($Path)
$Workbook = $com.Workbooks.Open("C:\myexcel.xls")
$com.Run("mymacro")
```

While the attack requires access to both TCP 135 for DCOM and TCP 445 for SMB, this is a relatively new vector for lateral movement and may avoid some detection systems such as Network Intrusion Detection or host-based antivirus.

---

>[!important]
>There are two other well-known lateral movement techniques worth mentioning: [abusing Windows Management Instrumentation](https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf) and a technique known as [PowerShell Remoting](https://docs.microsoft.com/en-gb/windows/win32/winrm/portal?redirectedfrom=MSDN). While we will not go into details of these methods here, they have their own advantages and drawbacks as well as multiple implementations in both PowerShell and Python.

---

# Active Directory Persistence

Once we have gained access and achieved the primary goals of the engagement, our next goal is to obtain persistence, ensuring that we do not lose our access to the compromised machines.

## Golden Ticket

Going back to the explanation of Kerberos authentication, we recall that when a user submits a request for a TGT, the KDC encrypts the TGT with a secret key known only to the KDCs in the domain.
This secret key is actually the password hash of a domain user account called [krbtgt](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn745899(v=ws.11)#Sec_KRBTGT).

If we are able to get our hands on the krbtgt password hash, we could create our own self-made custom TGTs, or **golden tickets**. For example, we could create a TGT stating that a non-privileged user is actually a member of the Domain Admins group, and the domain controller will trust it since it is correctly encrypted.

In order to craft our own Golden Ticket [^4], lets use [mimikatz](../Tools/mimikatz.md) again.

[^4]: [Craft a Golden Ticket](../Tools/mimikatz.md#Craft%20a%20Golden%20Ticket)

Note that by *creating our own TGT* and then *using PsExec*, **we are performing the overpass the hash attack** by leveraging Kerberos authentication. **If we were to connect using** PsExec to **the IP address** of the domain controller instead of the hostname, we would instead force the use of NTLM authentication and **access would still be blocked**.

## Domain Controller Sync

Another way to achieve persistence in an Active Directory infrastructure is to steal the password hashes for all administrative users in the domain.

To do this, we could move laterally to the domain controller and run [mimikatz](../Tools/mimikatz.md) to dump the password hash of every user.
We could also steal a copy of the [NTDS.dit](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961761(v=technet.10)?redirectedfrom=MSDN) database file, which is a copy of all Active Directory accounts stored on the hard drive, similar to the SAM database used for local accounts.

While these methods might work fine, they leave an access trail and may require us to upload tools.
An alternative is to abuse AD functionality itself to capture hashes remotely from a workstation.

In production environments, domains typically have more than one domain controller to provide redundancy.
The [Directory Replication Service Remote Protocol](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/f977faaa-673e-4f66-b9bf-48c640241d47?redirectedfrom=MSDN) uses [replication](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772726(v=ws.10)?redirectedfrom=MSDN) to synchronize these redundant domain controllers.
A domain controller may request an update for a specific object, like an account, with the [IDL_DRSGetNCChanges](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/b63730ac-614c-431c-9501-28d6aca91894?redirectedfrom=MSDN) API.

Luckily for us, the domain controller receiving a request for an update does not verify that the request came from a known domain controller, but only that the associated SID has appropriate privileges.
If we attempt to issue a rogue update request to a domain controller from a user who is a member of the Domain Admins group, it will succeed.

We’ll open [mimikatz](../Tools/mimikatz.md) and start the replication using `lsadump::dcsync` [^5] with the `/user` option to indicate the target user to sync, in this case the built-in domain administrator account Administrator

[^5]: [User Replication Updates](../Tools/mimikatz.md#User%20Replication%20Updates)

The dump contains multiple hashes associated with the last twenty-nine used user passwords as well as the hashes used with AES encryption.
Using the technique above, we can request a replication update with a domain controller and obtain the password hashes of every account in Active Directory without ever logging in to the domain controller.