>Stack canaries, named for their analogy to a canary in a coal mine, are used to detect a stack buffer overflow before execution of malicious code can occur. This method works by **placing a small integer, the value of which is randomly chosen at program start, in memory just before the stack return pointer**. Most buffer overflows overwrite memory from lower to higher memory addresses, so in order to overwrite the return pointer the canary value must also be overwritten. This value is checked to make sure it has not changed before a routine uses the return pointer on the stack [^1]
>
[^1]: https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries

```c
// ESP ---> [local vars] [cookie] [saved registers] [RET] [args]

cmp dword [cookie], MAGICAL_VALUE
je return
call abort_cookie_smashed

return:
ret
```

<iframe width="660" height="415" src="https://www.youtube.com/embed/dbVvypaN8_k" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<iframe width="660" height="415" src="https://www.youtube.com/embed/4HxUmbOcN6Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


# Types of canaries

## Terminator canaries

*Terminator canaries* use the observation that most buffer overflow attacks are based on certain string operations which end at string terminators. The reaction to this observation is that the canaries are built of [null](https://en.wikipedia.org/wiki/Null_character) terminators, [CR](https://en.wikipedia.org/wiki/Carriage_return), LF, and [FF](https://en.wikipedia.org/wiki/Page_break#Form_feed). As a result, the attacker must write a null character before writing the return address to avoid altering the canary. This prevents attacks using `strcpy()` and other methods that return upon copying a null character, while the undesirable result is that the canary is known. Even with the protection, an attacker could potentially overwrite the canary with its known value and control information with mismatched values, thus passing the canary check code, which is executed soon before the specific processor's return-from-call instruction [^2].

[^2]: https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries

## Random canaries
*Random canaries* are randomly generated, usually from an [entropy](https://en.wikipedia.org/wiki/Entropy_(computing))-gathering [daemon](https://en.wikipedia.org/wiki/Daemon_(computer_software)), in order to prevent an attacker from knowing their value. Usually, it is not logically possible or plausible to read the canary for exploiting; the canary is a secure value known only by those who need to know itâ€”the buffer overflow protection code in this case.

Normally, a random canary is generated at program initialization, and stored in a global variable. This variable is usually padded by unmapped pages, so that attempting to read it using any kinds of tricks that exploit bugs to read off RAM cause a segmentation fault, terminating the program. It may still be possible to read the canary, if the attacker knows where it is, or can get the program to read from the stack.

## Random XOR canaries

*Random XOR canaries* are random canaries that are XOR-scrambled using all or part of the control data. In this way, once the canary or the control data is clobbered, the canary value is wrong.

Random XOR canaries have the same vulnerabilities as random canaries, except that the "read from stack" method of getting the canary is a bit more complicated. The attacker must get the canary, the algorithm, and the control data in order to re-generate the original canary needed to spoof the protection.

In addition, random XOR canaries can protect against a certain type of attack involving overflowing a buffer in a structure into a pointer to change the pointer to point at a piece of control data. Because of the XOR encoding, the canary will be wrong if the control data or return value is changed. Because of the pointer, the control data or return value can be changed without overflowing over the canary.

Although these canaries protect the control data from being altered by clobbered pointers, they do not protect any other data or the pointers themselves. Function pointers especially are a problem here, as they can be overflowed into and can execute [shellcode](https://en.wikipedia.org/wiki/Shellcode) when called.

# Attacks

## Bruteforce 32bit Stack Cookies

<iframe width="660" height="415" src="https://www.youtube.com/embed/KGzHcqJV-QM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Overwrite __stack_chk_fail@GOT using format strings and stack grooming

<iframe width="660" height="415" src="https://www.youtube.com/embed/AahpiYxKR2c" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
