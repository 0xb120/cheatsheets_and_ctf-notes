/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => ListCalloutsPlugin
});
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
function buildSettingCallout(root, callout) {
  root.empty();
  root.createDiv({
    cls: "markdown-source-view cm-s-obsidian mod-cm6 is-readable-line-width is-live-preview"
  }, (mockSrcView) => {
    mockSrcView.createDiv({
      cls: "HyperMD-list-line HyperMD-list-line-1 lc-list-callout cm-line",
      attr: {
        style: `text-indent: -8px; padding-left: 12px; --lc-callout-color: ${callout.color}`
      }
    }, (mockListLine) => {
      mockListLine.createSpan({
        cls: "cm-formatting cm-formatting-list cm-formatting-list-ul cm-list-1"
      }, (span) => {
        span.createSpan({ cls: "list-bullet", text: "-" });
        span.appendText(" ");
      });
      mockListLine.createSpan({ cls: "lc-list-bg" });
      mockListLine.createSpan({ cls: "lc-list-marker" }, (span) => {
        if (callout.icon) {
          (0, import_obsidian.setIcon)(span, callout.icon);
        } else {
          span.appendText(callout.char);
        }
      });
      mockListLine.createSpan({
        cls: "cm-list-1",
        text: " Sed eu nisl rhoncus, consectetur mi quis, scelerisque enim."
      });
    });
  });
}
function attachIconMenu(btn, onSelect) {
  let menuRef = null;
  const btnEl = btn.buttonEl;
  btn.onClick((e) => {
    e.preventDefault();
    const scrollParent = btnEl.closest(".vertical-tab-content");
    const destroyEventHandlers = () => {
      btnEl.win.removeEventListener("click", clickOutside);
      scrollParent.removeEventListener("scroll", scroll);
    };
    const clickOutside = (e2) => {
      if (menuRef) {
        if (!menuRef.contains(e2.targetNode)) {
          menuRef.detach();
          menuRef = null;
          destroyEventHandlers();
        }
      } else {
        destroyEventHandlers();
      }
    };
    const calcMenuPos = () => {
      let pos = `top: ${btnEl.offsetTop + btnEl.offsetHeight + 2 - scrollParent.scrollTop}px;`;
      if (import_obsidian.Platform.isMobile) {
        pos += ` right: ${btnEl.offsetParent.clientWidth - (btnEl.offsetLeft + btnEl.offsetWidth)}px;`;
      } else {
        pos += ` left: ${btnEl.offsetLeft}px;`;
      }
      menuRef.style.cssText = pos;
    };
    const scroll = () => {
      if (menuRef) {
        calcMenuPos();
      } else {
        destroyEventHandlers();
      }
    };
    if (menuRef) {
      destroyEventHandlers();
      menuRef.detach();
      menuRef = null;
      return;
    }
    createDiv("lc-menu", (menu) => {
      menuRef = menu;
      btnEl.after(menuRef);
      calcMenuPos();
      (0, import_obsidian.getIconIds)().forEach((icon) => {
        menuRef.createDiv("clickable-icon", (item) => {
          (0, import_obsidian.setIcon)(item, icon);
          item.onClickEvent(() => {
            btn.buttonEl.empty();
            btn.setIcon(icon);
            onSelect(icon);
            destroyEventHandlers();
            menuRef.detach();
            menuRef = null;
          });
        });
      });
    });
    btnEl.win.setTimeout(() => {
      btnEl.win.addEventListener("click", clickOutside);
      scrollParent.addEventListener("scroll", scroll);
    }, 10);
  });
}
function buildSetting(containerEl, plugin, index, callout, onDelete) {
  containerEl.createDiv({ cls: "lc-setting" }, (el) => {
    const calloutContainer = el.createDiv({ cls: "lc-callout-container" });
    buildSettingCallout(calloutContainer, callout);
    el.createDiv({ cls: "lc-input-container" }, (inputContainer) => {
      new import_obsidian.TextComponent(inputContainer).setValue(callout.char).onChange((value) => {
        if (!value)
          return;
        plugin.settings[index].char = value;
        plugin.saveSettings();
        buildSettingCallout(calloutContainer, plugin.settings[index]);
      });
      new import_obsidian.ButtonComponent(inputContainer).then((btn) => {
        if (callout.icon) {
          btn.setIcon(callout.icon);
        } else {
          btn.setButtonText("Set Icon");
        }
        attachIconMenu(btn, (icon) => {
          if (icon == null) {
            delete plugin.settings[index].icon;
          } else {
            plugin.settings[index].icon = icon;
          }
          plugin.saveSettings();
          buildSettingCallout(calloutContainer, plugin.settings[index]);
        });
      });
      if (callout.custom) {
        const [r, g, b] = callout.color.split(",").map((v) => parseInt(v.trim(), 10));
        const color = new import_obsidian.ColorComponent(inputContainer).setValueRgb({ r, g, b }).onChange((_value) => {
          const { r: r2, g: g2, b: b2 } = color.getValueRgb();
          plugin.settings[index].color = `${r2}, ${g2}, ${b2}`;
          plugin.saveSettings();
          buildSettingCallout(calloutContainer, plugin.settings[index]);
        });
      }
      if (callout.custom) {
        const rightAlign = inputContainer.createDiv({
          cls: "lc-input-right-align"
        });
        new import_obsidian.ButtonComponent(rightAlign).setButtonText("Delete").setWarning().onClick((_e) => {
          onDelete(index);
        });
      }
    });
  });
}
function buildNewCalloutSetting(containerEl, plugin, onSubmit) {
  const callout = {
    char: "",
    color: "158, 158, 158",
    icon: null,
    custom: true
  };
  containerEl.createDiv({ cls: "lc-setting" }, (settingContainer) => {
    settingContainer.createDiv({ cls: "setting-item-name" }, (e) => e.setText("Create a new Callout"));
    settingContainer.createDiv({ cls: "setting-item-description" }, (e) => e.setText("Create additional list callout styles."));
    const calloutContainer = settingContainer.createDiv({
      cls: "lc-callout-container"
    });
    const inputContainer = settingContainer.createDiv({
      cls: "lc-input-container"
    });
    const char = new import_obsidian.TextComponent(inputContainer).setValue("").setPlaceholder("...").onChange((value) => {
      callout.char = value;
      redraw();
    });
    const icon = new import_obsidian.ButtonComponent(inputContainer).setButtonText("Set Icon");
    attachIconMenu(icon, (icon2) => {
      if (icon2 == null) {
        delete callout.icon;
      } else {
        callout.icon = icon2;
      }
      redraw();
    });
    const color = new import_obsidian.ColorComponent(inputContainer).setValueRgb({ r: 127, g: 127, b: 127 }).onChange((_value) => {
      const { r, g, b } = color.getValueRgb();
      callout.color = `${r}, ${g}, ${b}`;
      redraw();
    });
    const rightAlign = inputContainer.createDiv({
      cls: "lc-input-right-align"
    });
    const submit = new import_obsidian.ButtonComponent(rightAlign).setButtonText("Create").setDisabled(true).onClick(() => {
      onSubmit(callout);
    });
    function redraw() {
      buildSettingCallout(calloutContainer, callout);
      const hasNoCharacter = callout.char.length === 0;
      const hasConflictingCharacter = plugin.settings.find((c) => c.char === char.getValue()) !== void 0;
      submit.setDisabled(hasNoCharacter || hasConflictingCharacter);
    }
    redraw();
  });
}
var ListCalloutSettings = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setDesc(createFragment((f) => {
      f.appendText("See the Style Settings plugin for additional configuration options.");
      f.append(createEl("br"));
      f.append(createEl("strong", {
        text: "Note: Using +, *, -, >, or # as the callout character can disrupt reading mode."
      }));
    }));
    this.plugin.settings.forEach((callout, index) => {
      buildSetting(containerEl, this.plugin, index, callout, (indexToDelete) => {
        this.plugin.settings.splice(indexToDelete, 1);
        this.plugin.saveSettings();
        this.display();
      });
    });
    buildNewCalloutSetting(containerEl, this.plugin, (callout) => {
      this.plugin.settings.push(callout);
      this.plugin.saveSettings();
      this.display();
    });
  }
};

// src/extension.ts
var import_view = __toModule(require("@codemirror/view"));
var import_state = __toModule(require("@codemirror/state"));
var import_obsidian2 = __toModule(require("obsidian"));
var setConfig = import_state.StateEffect.define();
var CalloutBackground = class extends import_view.WidgetType {
  toDOM() {
    return createSpan({
      cls: "lc-list-bg",
      attr: {
        "aria-hidden": "true"
      }
    });
  }
};
var CalloutMarker = class extends import_view.WidgetType {
  constructor(char, icon) {
    super();
    this.char = char;
    this.icon = icon;
  }
  toDOM() {
    return createSpan({
      text: this.char,
      cls: "lc-list-marker",
      attr: {
        "aria-hidden": "true"
      }
    }, (s) => {
      if (this.icon) {
        (0, import_obsidian2.setIcon)(s, this.icon);
      }
    });
  }
};
var calloutDecoration = (color) => import_view.Decoration.line({
  attributes: {
    class: "lc-list-callout",
    style: `--lc-callout-color: ${color}`
  }
});
var calloutsConfigField = import_state.StateField.define({
  create() {
    return [];
  },
  update(state, tr) {
    for (const e of tr.effects) {
      if (e.is(setConfig)) {
        state = e.value;
      }
    }
    return state;
  }
});
function buildCalloutDecos(view) {
  const config = view.state.field(calloutsConfigField);
  if (!config.length)
    return import_view.Decoration.none;
  const builder = new import_state.RangeSetBuilder();
  const seen = new Set();
  for (const { from, to } of view.visibleRanges) {
    for (let pos = from; pos <= to; ) {
      const line = view.state.doc.lineAt(pos);
      for (const callout of config) {
        const match = line.text.match(callout.re);
        if (match) {
          if (seen.has(line.from))
            break;
          seen.add(line.from);
          const labelPos = line.from + match[1].length;
          builder.add(line.from, line.from, calloutDecoration(callout.color));
          builder.add(labelPos, labelPos + callout.char.length, import_view.Decoration.replace({
            widget: new CalloutMarker(callout.char, callout.icon)
          }));
          builder.add(line.to, line.to, import_view.Decoration.widget({
            widget: new CalloutBackground(),
            side: 1
          }));
          break;
        }
      }
      pos = line.to + 1;
    }
  }
  return builder.finish();
}
var calloutExtension = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = buildCalloutDecos(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(setConfig)))) {
      this.decorations = buildCalloutDecos(update.view);
    }
  }
}, {
  decorations: (v) => v.decorations
});

// src/postProcessor.ts
var import_obsidian3 = __toModule(require("obsidian"));
function getFirstTextNode(li) {
  for (const node of li.childNodes) {
    if (node.nodeType === document.ELEMENT_NODE && node.tagName === "P") {
      return node.firstChild;
    }
    if (node.nodeType !== document.TEXT_NODE) {
      continue;
    }
    if (node.nodeValue.trim() === "") {
      continue;
    }
    return node;
  }
  return null;
}
function wrapLiContent(li) {
  const toReplace = [];
  let insertBefore = null;
  for (let i = 0, len = li.childNodes.length; i < len; i++) {
    const child = li.childNodes.item(i);
    if (child.nodeType === document.ELEMENT_NODE) {
      const el = child;
      if (el.hasClass("list-collapse-indicator") || el.hasClass("list-bullet")) {
        continue;
      }
      if (["UL", "OL"].includes(el.tagName)) {
        insertBefore = child;
        break;
      }
    }
    toReplace.push(child);
  }
  const wrapper = createSpan({ cls: "lc-li-wrapper" });
  toReplace.forEach((node) => wrapper.append(node));
  if (insertBefore) {
    insertBefore.before(wrapper);
  } else {
    li.append(wrapper);
  }
}
function buildPostProcessor(getConfig) {
  return (el) => {
    const config = getConfig();
    el.findAll("li").forEach((li) => {
      const node = getFirstTextNode(li);
      if (!node)
        return;
      const text = node.textContent;
      if (!text)
        return;
      for (const callout of config) {
        const match = text.match(callout.re);
        if (match) {
          li.addClass("lc-list-callout");
          li.style.setProperty("--lc-callout-color", callout.color);
          node.replaceWith(createFragment((f) => {
            f.append(createSpan({
              cls: "lc-list-marker",
              text: text.slice(0, callout.char.length)
            }, (span) => {
              if (callout.icon) {
                (0, import_obsidian3.setIcon)(span, callout.icon);
              }
            }));
            f.append(text.slice(callout.char.length));
          }));
          wrapLiContent(li);
          break;
        }
      }
    });
  };
}

// src/main.ts
var DEFAULT_SETTINGS = [
  {
    color: "255, 214, 0",
    char: "&"
  },
  {
    color: "255, 145, 0",
    char: "?"
  },
  {
    color: "255, 23, 68",
    char: "!"
  },
  {
    color: "124, 77, 255",
    char: "~"
  },
  {
    color: "0, 184, 212",
    char: "@"
  },
  {
    color: "0, 200, 83",
    char: "$"
  },
  {
    color: "158, 158, 158",
    char: "%"
  }
];
var ListCalloutsPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.emitSettingsUpdate = (0, import_obsidian4.debounce)(() => this.dispatchUpdate(), 2e3, true);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.buildPostProcessorConfig();
      this.addSettingTab(new ListCalloutSettings(this));
      this.emitter = new import_obsidian4.Events();
      this.registerMarkdownPostProcessor(buildPostProcessor(() => this.postProcessorConfig));
      this.registerEditorExtension([
        calloutsConfigField.init(() => {
          return this.buildEditorConfig();
        }),
        calloutExtension
      ]);
      app.workspace.trigger("parse-style-settings");
    });
  }
  dispatchUpdate() {
    const newConfig = this.buildEditorConfig();
    app.workspace.getLeavesOfType("markdown").find((l) => {
      const view = l.view;
      const cm = view.editor.cm;
      cm == null ? void 0 : cm.dispatch({
        effects: [setConfig.of(newConfig)]
      });
    });
  }
  buildEditorConfig() {
    return this.settings.map((callout) => {
      return __spreadProps(__spreadValues({}, callout), {
        re: new RegExp(`(^\\s*[-*+](?: \\[.\\])? |^\\s*\\d+[\\.\\)](?: \\[.\\])? )${escapeStringRegexp(callout.char)} `)
      });
    });
  }
  buildPostProcessorConfig() {
    this.postProcessorConfig = this.settings.map((callout) => {
      return __spreadProps(__spreadValues({}, callout), {
        re: new RegExp(`^${escapeStringRegexp(callout.char)} `)
      });
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      const loadedSettings = yield this.loadData();
      const customCallouts = loadedSettings == null ? void 0 : loadedSettings.filter((callout) => callout.custom === true);
      const modifiedBuiltins = loadedSettings == null ? void 0 : loadedSettings.filter((callout) => callout.custom !== true);
      this.settings = DEFAULT_SETTINGS.map((s, i) => {
        return Object.assign({}, s, modifiedBuiltins ? modifiedBuiltins[i] : {});
      });
      if (customCallouts) {
        this.settings.push(...customCallouts);
      }
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.emitSettingsUpdate();
      this.buildPostProcessorConfig();
    });
  }
};
