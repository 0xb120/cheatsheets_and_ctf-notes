---
raindrop_id: 1334349752
raindrop_highlights:
  68c29b799c6f15ca4ebdab61: 0a4669c78c4bbd94216e66635dde919a
  68c29b83a04e81c1a41775de: 2de793837eeb0eeaace1e009bd77a704
  68c29bc6a1ddd74ed7a36f96: 685f71545747cfe23845f28f92c853f1
  68c29bd69c6f15ca4ebdc07c: 6e42397c542dd04ae8174eacbf69653e
  68c29bed4297bb046803d5ff: 365424432f6857f4d351bae3eb1690d5
  68c29bff9c6f15ca4ebdc6ae: 8c6d2f177517c975768728e478324de5
  68c29c054ea391c352ce3e72: b63a82a8941875f9806b2d04f1268ea2
  68c29c147f46d1fd8d3f6463: 0572dc22d05837d8a199080a9c85cf9a
  68c29c2ad2ed0dc7b42458c7: 83df5fcab8bf02c9dc4bf24b74c4e3a9
  68c29c366552a70713d65a34: cb6ca8d73ffbca2b37892605f3d6f01a
  68c29c494ea391c352ce4dff: 5312211ba5d28d73e06df80226c70a7d
  68c29c4d4297bb046803e9f7: 56aa907bbd19e8a125993bda88238135
  68c29c607f46d1fd8d3f76fb: 867d12c4ce11819e156994a8fe08e3f5
  68c29c6f6552a70713d669b2: a3a46759655b7b1016d67ab213628c9f
  68c29c74a04e81c1a417abea: 27966ec12acddf9583bee9d6cd00b6e2
  68c29c78a04e81c1a417acd2: 13a10d80d0e4d845e2fbf941d0fd5409
  68c29c7b185ce84b580ed6cb: 71246a0a39f0e05cd2313bf480acbdf7
  68c29c89a1ea3e9618316ab2: 463a42c08b6f2775af19af0ab9e47ffa
  68c29c8fb30cf7eee0d88638: 21639a5cb09bfa47aedc8856a3d4869b
title: "Unleashing the Hound: How AI Agents Find Deep Logic Bugs in Any Codebase"

description: |-
  Unleashing the Hound: How AI Agents Find Deep Logic Bugs in Any Codebase Hound is a language-agnostic AI code security auditor that simulates the cognitive processes of human experts. It maps systems …

source: https://muellerberndt.medium.com/unleashing-the-hound-how-ai-agents-find-deep-logic-bugs-in-any-codebase-64c2110e3a6f

created: 1757580644227
type: link
tags:
  - "_index"

 
  - "AI" 
  - "LLM" 
  - "SAST" 
  - "Tools"

---
# Unleashing the Hound: How AI Agents Find Deep Logic Bugs in Any Codebase

![](https://miro.medium.com/v2/resize:fit:1200/1*gKl-NK3jLUKY7zDsQVFs6Q.jpeg)

> [!summary]
> Unleashing the Hound: How AI Agents Find Deep Logic Bugs in Any Codebase Hound is a language-agnostic AI code security auditor that simulates the cognitive processes of human experts. It maps systems …





Hound is a language-agnostic AI code security auditor that simulates the cognitive processes of human experts.
It maps systems as living knowledge graphs, and uses focused, high-quality hypotheses from strong reasoning models to find deep logic bugs across any stack.
How it works
Hound first generates language-agnostic code cards: contiguous byte slices created by linear chunking, each annotated with char_start and char_end offsets to ensure complete, non-overlapping coverage of every file.
Graph nodes (functions, storage, roles) and edges are evidence‑backed: they store references to the exact code‑card IDs and character spans where a definition or use appears, using multiple spans if a symbol crosses slices.
A typical graph generated by Hound. This graph models the functional flows related to executing a leverage strategy.
In practice
In total, we need to configure 5 models for various roles.
The “agent” and “guidance” models perform the bulk of the analysis. The agent model— usually a smaller model — represents a junior auditor. It navigates the graph, selects slices, pulls relevant nodes into view, and annotates nodes with observations, escalating questions when it gets stuck. The guidance model (a.k.a. senior security researcher) creates high-level plans, periodically reviews the junior’s actions, and, crucially, owns vulnerability hypothesis generation.
The “finalize” model is responsible for a separate QA step at the end of the audit.
I kicked off a new project and asked Hound to build five knowledge graphs
./hound.py project create
./hound.py graph build secondswap - graphs 5 - iterations 8 - files "contracts/SecondSwap_Marketplace.sol,contracts/SecondSwap_MarketplaceSetting.sol,contracts/SecondSwap_StepVesting.sol,contracts/SecondSwap_VestingDeployer.sol,contracts/SecondSwap_VestingManager.sol,contracts/SecondSwap_Whitelist.sol,contracts/SecondSwap_WhitelistDeployer.sol,contracts/USDT.sol"`
Those initial graphs are Hound’s first working understanding
Using the graph models, the model can fluidly relate details across granularities — local code paths, component‑level behavior, and system‑level invariants — whenever it matters.
Exploration, investigation, and hypothesis formation
Once the graphs are done, our auditors can go to work.
./hound.py agent audit secondswap - time-limit 180`
Annotations will show up in the graph if you re-export it to HTML during or after the audit:

./hound.py graph export secondswap
Node annotations allow the agents to capture assumptions and observations. This allows the agent to reason about relationship between abstract and/or concrete concepts.