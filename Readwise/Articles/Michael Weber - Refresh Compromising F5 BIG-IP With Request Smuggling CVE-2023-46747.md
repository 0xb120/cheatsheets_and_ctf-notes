---
author: Michael Weber
aliases:
  - "Refresh: Compromising F5 BIG-IP With Request Smuggling | CVE-2023-46747"
tags:
  - readwise/articles
  - tomcat
url: https://www.praetorian.com/blog/refresh-compromising-f5-big-ip-with-request-smuggling-cve-2023-46747/?__readwiseLocation=
created: 2024-08-20
---
# Refresh: Compromising F5 BIG-IP With Request Smuggling | CVE-2023-46747

![rw-book-cover](https://www.praetorian.com/wp-content/uploads/2023/10/Vulnerability-Research-at-Praetorian-Labs.png)

**Vulnerability:** Authentication Bypass & RCE **CVE ID:** [CVE-2023-46747](https://www.cve.org/CVERecord?id=CVE-2023-46747) (Related to CVE-2022-26377) **Target:** F5 BIG-IP Traffic Management User Interface (TMUI)

---

## 1. Executive Summary

Researchers at Praetorian successfully identified and exploited a critical authentication bypass vulnerability in [[F5]] BIG-IP systems. This vulnerability allows an unauthenticated attacker to execute arbitrary system commands as `root` through the Traffic Management User Interface (TMUI). The issue stems from a request smuggling discrepancy between the frontend and the backend [[tomcat]] server, specifically leveraging the [Apache JServ Protocol (AJP)](../../Dev,%20ICT%20&%20Cybersec/Services/Apache%20JServ%20Protocol%20(AJP).md).

## 2. Reconnaissance & Root Cause Analysis

Using a standard F5 installation via the AWS Marketplace, researchers investigated the relationship between the frontend web server and the backend Java components.

- **The Architecture:** The investigation of `/usr/share/tomcat/conf/server.xml` confirmed that the underlying Tomcat server utilized an **AJP connector**.
    
- **The Theory:** Previous vulnerabilities (2020 and 2022) suggested that discrepancies in how frontend and backend systems interpret requests often lead to bypasses.
    
- **The Smuggling Vector:** The team identified that the F5 vulnerability was a request smuggling issue closely related to [CVE-2022-26377](https://www.cve.org/CVERecord?id=CVE-2022-26377).
    

## 3. Developing the Exploit

### Initial Trigger

By adapting a Proof of Concept (PoC) for AJP smuggling (originally detailed by RicterZ), the researchers targeted the exposed `/tmui/login.jsp` endpoint.

Using the following command, they attempted to confuse the server's interpretation of the request boundaries:

```sh
$ curl -k -i http://target:8443/tmui/login.jsp -H 'Transfer-Encoding: chunked, chunked' --data-binary @raw.dat
```

```txt
$ xxd raw.dat

00000000: 0008 4854 5450 2f31 2e31 0000 012f 0000  ..HTTP/1.1.../..

00000010: 0931 3237 2e30 2e30 2e31 00ff ff00 0161  .127.0.0.1.....a

00000020: 0000 5000 0000 0a00 216a 6176 6178 2e73  ..P.....!javax.s

00000030: 6572 766c 6574 2e69 6e63 6c75 6465 2e72  ervlet.include.r

00000040: 6571 7565 7374 5f75 7269 0000 012f 000a  equest_uri.../..

00000050: 0022 6a61 7661 782e 7365 7276 6c65 742e  ."javax.servlet.

00000060: 696e 636c 7564 652e 7365 7276 6c65 745f  include.servlet_

00000070: 7061 7468 0001 532f 2f2f 2f2f 2f2f 2f2f  path..S/////////

00000080: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000090: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000000a0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000000b0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000000c0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000000d0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000000e0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000000f0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000100: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000110: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000120: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000130: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000140: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000150: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000160: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000170: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000180: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

00000190: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000001a0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000001b0: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////

000001c0: 2f2f 2f2f 2f2f 2f2f 2f2f 000a 001f 6a61  //////////....ja

000001d0: 7661 782e 7365 7276 6c65 742e 696e 636c  vax.servlet.incl

000001e0: 7564 652e 7061 7468 5f69 6e66 6f00 0010  ude.path_info...

000001f0: 2f57 4542 2d49 4e46 2f77 6562 2e78 6d6c  /WEB-INF/web.xml

00000200: 00ff
```

Initially, this resulted in **404 Not Found** errors. This occurred because F5 BIG-IP does not run a ROOT webapp by default. However, by manually creating a file at the ROOT path, they confirmed the ability to trigger "GhostCat" style [Local File Inclusion (LFI & RFI)](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/File%20Inclusion%20(LFI%20&%20RFI).md), proving the AJP smuggling vector was active.

### The Objective: Arbitrary Servlet Invocation

The Tomcat AJP connector **directs web traffic to backend Java servlets**. Smuggling arbitrary AJP packets would allow the **invocation of backend logic with attacker-controlled data**. However, the team faced three strict constraints:

1. **Size Limit:** POST requests had to be exactly **0x204 (518) bytes**.
    
2. **No Body Content:** The smuggled request could not successfully transmit a POST body.
    
3. **Scope:** Routing was limited to `/tmui` API endpoints.
    

### Overcoming Constraints

Since the team could not execute complex code paths due to the inability to send a POST body, they pivoted to a simpler goal: **Creating a new Administrator User.**

Validating a legitimate user creation request revealed it required a large 1726-byte POST body and a valid session cookie—both of which were blocked by the exploit constraints. They circumvented these protections using the following techniques:

- **Bypassing the Body (Constraint 2):** They discovered that the backend accepted payload data via **query parameters** instead of the POST body.
    
- **Bypassing Authentication:** They injected a custom header, **`REMOTEROLE: 0`**, into the smuggled AJP request. This trick convinced the backend that the request was initiated by an authenticated administrator.
    
- **Bypassing Size Limits (Constraint 1):** To fit the strict 518-byte limit, they iteratively stripped non-essential parameters (such as `exit_button_before` and `enableObjList`) until the payload was small enough to pass.
    

## 4. Impact

The result was a repeatable exploit chain:

1. Send a smuggled AJP request with the `REMOTEROLE: 0` header.
    
2. Pass user creation details via query parameters.
    
3. **Result:** A new administrator user is created on the backend.
    

Once the user is created, the attacker can log in via the standard web interface and utilize the legitimate "mgmt" API to execute arbitrary commands, leading to complete system compromise.

## Highlights


> Authentication bypass issue that led to complete compromise of an F5 system with the Traffic Management User Interface (TMUI) exposed. The bypass was assigned [CVE-2023-46747](https://www.cve.org/CVERecord?id=CVE-2023-46747), and is closely related to [CVE-2022-26377](https://www.cve.org/CVERecord?id=CVE-2022-26377).
> [View Highlight](https://read.readwise.io/read/01hea8d2ekk1x13sb80ennv3g2)



> the F5 vulnerability was also a [HTTP Request Smuggling](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/HTTP%20Request%20Smuggling.md) issue.
> [View Highlight](https://read.readwise.io/read/01hea8d8yg99gzvj196tw55z60)



> proof of concept on Github
> [View Highlight](https://read.readwise.io/read/01hea8br3e5vapsjccj3nfbmgs)



> We deployed a default F5 installation using a cheap [AWS Marketplace template](https://aws.amazon.com/marketplace/pp/prodview-lphsy6izllsmq?sr=0-1&ref_=beagle&applicationId=AWSMPContessa) and began identifying components on the server.
> [View Highlight](https://read.readwise.io/read/01hea8j0s3mkb9a2ey05q0pz3t)



> We knew from the previously discussed F5 vulnerabilities from 2020 and 2022 that a discrepancy in the way that frontend and backend systems interpreted a request was likely to result in an authentication bypass issue.
> [View Highlight](https://read.readwise.io/read/01hea8m91e8ba5298myg5c9jvg)



> One of CVE-2022-26377’s original reporters wrote an [excellent blog post](https://ricterz-me.translate.goog/posts/2022-03-03-a-new-attack-method-ajp-request-smuggling.txt?_x_tr_sl=auto&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp) describing the straightforward exploitation of the vulnerability.
> [View Highlight](https://read.readwise.io/read/01hea8n9bays8kfz51rdr0epqb)



> A look at `/usr/share/tomcat/conf/server.xml` confirmed the usage of an AJP connector on #tomcat ,
> [View Highlight](https://read.readwise.io/read/01hea8pmq8rkt0bzd11s1av8p5)



> At a glance it appeared that hitting any `/tmui/` URL would be sufficient to trigger AJP smuggling.
> [View Highlight](https://read.readwise.io/read/01hea932e5k8vrbwby8dgs46ka)



> we took the example AJP payload implementation from [RicterZ’s blog post](https://ricterz-me.translate.goog/posts/2022-03-03-a-new-attack-method-ajp-request-smuggling.txt?_x_tr_sl=auto&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=wapp)  and pointed it at a URL we knew would be publicly exposed–the login page.
> [View Highlight](https://read.readwise.io/read/01hea93cddchdc1f5q0bavf0m7)



> $ curl -k -i http://our.f5.ami.ip:8443/tmui/login.jsp -H 'Transfer-Encoding: chunked, chunked' --data-binary @raw.dat
> [View Highlight](https://read.readwise.io/read/01hea951vxzwqw809c8thpm97v)



> Interestingly enough, after a few curl requests, we occasionally would receive 404 Not Found responses instead of the expected login page.
> [View Highlight](https://read.readwise.io/read/01hea95ya8wmphss70wc01v6md)



> By default the F5-BIGIP does not run a ROOT webapp, so the system returned a 404 instead. By explicitly creating a file at /usr/share/tomcat/webapps/ROOT/WEB-INF/web.xml, we were able to trigger the GhostCat LFI.
> [View Highlight](https://read.readwise.io/read/01hea97yq6ng1qeym3gtm40z2f)



> So what exactly can we do with the ability to send arbitrary AJP packets? The Tomcat AJP connector is one mechanism for directing web request content to backend Java servlets. These servlets contain the conventional backend processing logic.
> [View Highlight](https://read.readwise.io/read/01hea9qarcfte3jkef6rb87qvd)



> If we could smuggle completely arbitrary data as AJP packets this would give us the ability to invoke arbitrary servlets with entirely arbitrary content.
> [View Highlight](https://read.readwise.io/read/01hea9qxky2va64axxj4jfvyfa)



> First, POST requests needed to be exactly 0x204 bytes (518).
> [View Highlight](https://read.readwise.io/read/01hea9r3jd3w4dbr1xz1xvxjhg)



> Next, we could not actually send any POST body content with the smuggled request.
> [View Highlight](https://read.readwise.io/read/01hea9rcx2eme6jzt0qhydhftg)



> Finally, we could only route to endpoints in the “/tmui” API.
> [View Highlight](https://read.readwise.io/read/01hea9rnf138h4x3tx38ksg1ze)



> While we identified some interesting attack surface, such as potential paths to some classic Java deserialization attacks, the lack of ability to send a POST body prevented us from reaching those code paths
> [View Highlight](https://read.readwise.io/read/01hea9s671yttt56mr4hw5vg9e)



> Eventually, we realized it might be easier to simply create a user for ourselves.
> [View Highlight](https://read.readwise.io/read/01hea9sfjt56635pnwxak1jrk6)



> We verified that the request created a new administrator user on the backend, and sent another one to make sure it was the only request required (it was). However, we noticed a few important attributes that would preclude us from replicating and smuggling that same request to the backend. First, the content itself is sent as a POST body and the smuggled AJP request will not send POST body content properly. Second, the request included a Cookie that was set after we logged in to the application, so somehow we would need to determine if there is another way to authenticate to the relevant part of the code without that Cookie. Finally, the POST body Content-Length is 1726 bytes, which is much greater than our strict 518 byte requirement
> [View Highlight](https://read.readwise.io/read/01hea9vn9d40wbzwzqmsbsp2fw)



> sending the POST body content as request query parameters worked and addressed the first of the three issues.
> [View Highlight](https://read.readwise.io/read/01heaa5gayb96gbty0va54pvhg)



> So to create the user successfully we simply added a “REMOTEROLE” header with value “0” to the smuggled AJP request
> [View Highlight](https://read.readwise.io/read/01heaa9asgjd1x8q5axnn875ys)



> We started stripping out a few parameters like “exit_button_before” and “enableObjList” at a time. After removing them, we resent the request and checked that it still created a new user. And then we repeated the process again and again.
> [View Highlight](https://read.readwise.io/read/01heaaah1nbndkrh2esas2y64g)



> After sending the smuggled request to create valid administrator credentials, we could authenticate to the F5 system using the standard authentication flow and run arbitrary commands through the “mgmt” API.
> [View Highlight](https://read.readwise.io/read/01heaabfzpr1qyde6h2y80a341)

