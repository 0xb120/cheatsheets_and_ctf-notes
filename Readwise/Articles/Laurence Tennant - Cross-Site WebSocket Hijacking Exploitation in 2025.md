---
author: Laurence Tennant
aliases:
  - Cross-Site WebSocket Hijacking Exploitation in 2025
  - Total Cookie Protection
tags:
  - readwise/articles
url: https://blog.includesecurity.com/2025/04/cross-site-websocket-hijacking-exploitation-in-2025/?__readwiseLocation=
date: 2025-04-22
---
# Cross-Site WebSocket Hijacking Exploitation in 2025

[Cross-Site WebSocket Hijacking](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/WebSockets.md) (CSWSH) vulnerabilities [](https://read.readwise.io/read/01jse6v3b5ab7k9e6zn9eq8y50) wouldn’t work today in all browsers. This is due to improvements in baseline security in browsers around cross-origin requests. These improvements include Third Party Cookie Restrictions,Total Cookie Protection, and Private Network Access. [](https://read.readwise.io/read/01jse6vqb1kv4zvhg1vv5j32b2)

I’ve not been able to find much discussion about the increasing limitations on CSWSH – apart from a passing mention in [this excellent primer](https://www.blackhillsinfosec.com/cant-stop-wont-stop-hijacking-websockets/). [](https://read.readwise.io/read/01jse6wwqhwyzpkc90ydwn44zr)

This blog post explores the current state of browser mitigations that make CSWSH harder to exploit. [](https://read.readwise.io/read/01jse6x6qdan4tem7sr98p6jvw)



## CSWSH Mitigation

The definitive way to mitigate CSWSH is that the WebSocket server should first check the Origin [^1] of the WebSocket handshake request. If the request does not come from a trusted and expected Origin, then the WebSocket handshake should fail. [](https://read.readwise.io/read/01jse707m2tyn8mecnqqzhbffr)

There are some workarounds such as putting a token in the [Sec-WebSocket-Protocol header](https://ably.com/blog/websocket-authentication) or authenticating in the first WebSocket message. [](https://read.readwise.io/read/01jse71tmejtnkv3fhmmzxkme1)

### CSWSH Prerequisites

There are a number of prerequisites for a CSWSH attack to work: 
1) The app uses cookie-based authentication 
2) The authentication cookie is set to `SameSite=None` [^2]
3) The WebSocket server does not validate the Origin of the Websocket handshake request (and does not use another means to validate the source of requests, such as authenticating in the first WebSocket message). [](https://read.readwise.io/read/01jse72pr2pknvjj9wvbjts2kd)

## Mitigations

Now let’s discuss current browser security measures and how these make CSWSH attacks harder to achieve than they used to be. [](https://read.readwise.io/read/01jse742zpeksgaww4a3y3b9dw)

### SameSite=Lax by default

`SameSite=Lax` by default is a longstanding and effective browser default that affects CSWSH attacks. [](https://read.readwise.io/read/01jse74fbamzsht7zf2cha0z5k) [^2]

SameSite=Lax means that browsers will send cookies in cross-site requests only for GET requests that resulted from a top-level navigation by the user, like clicking a link. [](https://read.readwise.io/read/01jse75epedjhqxzgem98te4s1)

>[!important]
>Note that [not all browsers set SameSite=Lax by default](https://caniuse.com/mdn-http_headers_set-cookie_samesite_lax_default). [](https://read.readwise.io/read/01jse76ntrwr5n7s005mta1zg9)

For *implicit* `SameSite=Lax`, there is a **two minute grace period** after the cookie is issued where cookies are still sent with top-level cross-site POST requests. [](https://read.readwise.io/read/01jse780xjfcexkqs78j64czn8) [^3]

However, it **does not apply** to CSWSH attacks, since WebSocket handshakes are not top-level POST requests. Therefore SameSite needs to explicitly be set to None for CSWSH attacks to work [](https://read.readwise.io/read/01jse798fydjk3hzg853qcqtn1)

### Total Cookie Protection

Over the past several years **Firefox** has been locking down their [“Enhanced Tracking Protection” feature](https://chromestatus.com/feature/5088147346030592). [](https://read.readwise.io/read/01jse7bccwzdynmyw1z7sv11nj). Sometime in 2022-2024 “Total Cookie Protection” was enabled by default for the whole userbase, and this is really effective at blocking CSWSH. [](https://read.readwise.io/read/01jse7bptfbjcs0p9n94zk97a0)

Total Cookie Protection works by isolating cookies to the site in which they are created. Essentially each site has its own cookie storage partition to prevent third parties linking a user’s browsing history together. [](https://read.readwise.io/read/01jse7cbxx4bscx59rbpmtd3z4)

It also has the side-effect of stopping cookie-based CSWSH. A malicious site cannot perform a successful cross-site WebSocket handshake with a user’s cookie, since that cookie is outside the current cookie storage partition. This applies even if the cookie is configured as SameSite=None. [](https://read.readwise.io/read/01jse7dw9prettj5x8pjgzkpj4)

### Private Network Access

The [Private Network Access specification](https://wicg.github.io/private-network-access/) acknowledges that an increasing amount of services run on a user’s localhost and their private network, and describes a control similar to [Cross-origin resource sharing (CORS)](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/Cross-origin%20resource%20sharing%20(CORS).md) to prevent public Internet resources from making unapproved requests to private resources. See for instance [this incredible writeup against Tailscale](https://emily.id.au/tailscale). [](https://read.readwise.io/read/01jse7m11yq0zx7v1mh2jzwfpy)

A request (even a GET request) that is made from a more public to a more private address space triggers a preflight `OPTIONS` request that has the `Access-Control-Request-Private-Network: true` header attached by Chrome, and must receive a corresponding `Access-Control-Allow-Private-Network: true` header in the response for the main request to be sent. [](https://read.readwise.io/read/01jse7n8ec93f7a9sfqadwggtq)

However, I found that CSWSH attacks against private IPs are not affected by Private Network Access. [](https://read.readwise.io/read/01jse7nn6nr9rsvrs1jtk5yaqq). This makes sense, and is [called out in the specification](https://wicg.github.io/private-network-access/#integration-websockets), since Private Network Access uses CORS preflight requests as the protection method, and WebSockets do not follow SOP and thus do not use preflight requests. [](https://read.readwise.io/read/01jse7pvj58qa0a3j36w07gzv2)

## Testing
To verify all the points made above, I made a small demo app, the source code is at [https://github.com/IncludeSecurity/cswsh-demo](https://github.com/IncludeSecurity/cswsh-demo ) [](https://read.readwise.io/read/01jse7qb23y70h96p2q54759e9)

[^1]:[Origins vs Sites](jakearchibald.com%20-%20How%20to%20Win%20at%20CORS.md#Origins%20vs%20Sites)

[^2]: [SameSite Cookie Attribute](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/SameSite%20Cookie%20Attribute.md)

[^3]: [Bypass SameSite Lax restrictions with newly issued cookies](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/SameSite%20Cookie%20Attribute.md#Bypass%20SameSite%20Lax%20restrictions%20with%20newly%20issued%20cookies)

