---
author: Vulnerability Researcher
aliases:
  - "Next.js and Cache Poisoning: A Quest for the Black Hole"
tags:
  - readwise/articles
  - nextjs
url: https://zhero-web-sec.github.io/research-and-things/nextjs-and-cache-poisoning-a-quest-for-the-black-hole?__readwiseLocation=
date: 2025-03-05
summary:
---
# Next.js and Cache Poisoning: A Quest for the Black Hole

>[!tldr]
>This article will focus on [Web Cache Poisoning](../../Dev,%20ICT%20&%20Cybersec/Web%20&%20Network%20Hacking/Web%20Cache%20Poisoning.md). [](https://read.readwise.io/read/01jnjz58as6y84wgms8aye638a)


**Next.js**, an open-source JavaScript framework based on React. [](https://read.readwise.io/read/01jnjz4tsx7a0e73p0678gjbr8)

## Cache Poisoning using `x-middleware-prefetch`

Interesting behavior **related to the Next.js middleware**. When prefetching data for SSR (server-side rendering) pages, adding the `x-middleware-prefetch` header results in an empty JSON object `{}` as a response. [](https://read.readwise.io/read/01jnjz6zehphcx8xd813gyfszt)

The primary condition for reproducibility/exploitation is the presence of a caching system. [](https://read.readwise.io/read/01jnjz9mw2m2gvkpmcjan4mvp8)

Since [version 13.4.20-canary.13](https://github.com/advisories/GHSA-c59h-r6p8-q9wc), Next.js has added **cache-control** to SSR responses to prevent them from being cached.
 ![](https://zhero-web-sec.github.io/images/next-cache-2.png) [](https://read.readwise.io/read/01jnjzacc3e4c3y18r3y99bazw)

This vulnerability already had a [CVE assigned](https://nvd.nist.gov/vuln/detail/CVE-2023-46298) (**CVE-2023-46298**). However, since the proof of concept (POC) had not yet been shared, I was still able to exploit this vulnerability on a large scale. [](https://read.readwise.io/read/01jnjzb3zkkjvppmhq5sdp7bac)


## React Server Component and CDNs, a food poisoning using `Rsc: 1`

What is React Component Server (RSC)? Answer from the [official next.js documentation](https://nextjs.org/learn/react-foundations/server-and-client-components):
 > The RSC Payload is a compact binary representation of the rendered React Server Components tree. It’s used by React on the client to update the browser’s DOM. The RSC Payload contains:
 > 
 > • The rendered result of Server Components
 > • Placeholders for where Client Components should be rendered and references to their JavaScript files
 > • Any props passed from a Server Component to a Client Component
 To put it simply, this feature allows you to render React components directly on the server before sending them to the client. [](https://read.readwise.io/read/01jnjzd1p4p2twp5hm2arn58np)

The header responsible for this behavior —`Rsc: 1`— was added to the cache-key via the `Vary` response header, **theoretically** preventing cache-poisoning.
 ![](https://zhero-web-sec.github.io/images/next-cache-4.png) [](https://read.readwise.io/read/01jnjzdt537265hntq86seqgqb)

By inspecting my HTTP history on my proxy, I noticed that the requests fetching the RSC payload included a **URL parameter** that was systematically added: `_rsc=randomValue`. [](https://read.readwise.io/read/01jnjzesp41xkemz71rq2pkqmt) This was a **cache-buster used to prevent caching an “unwanted” response**, which was surprising given that, as mentioned previously, the header was added to the cache-key via `vary`. [](https://read.readwise.io/read/01jnjzg96dq1km86dq67wzryz0)

Long story short: **the framework was cache-poisoning itself and the addition of the URL parameter was to prevent this behavior**. [](https://read.readwise.io/read/01jnjzjdbgvraxxz6z52nqt6ht)

Quick reminder about the function of the `vary` response header from the [Mozilla documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary):
 > The Vary HTTP response header describes the parts of the request message aside from the method and URL that influenced the content of the response it occurs in. Most often, this is used to create a cache key when content negotiation is in use. [](https://read.readwise.io/read/01jnjzkp5tjz5fpx4mv2xffn0j)

### Do CDNs really not respect `vary` values?

 As surprising as it may be, after digging into the documentation of various CDNs, it turns out to be true under certain conditions. [](https://read.readwise.io/read/01jnjzrf1f15ygsyth3ejjrhnf)

We discussed earlier the self-cache-poisoning issue caused by the framework, prompting Next.js developers to implement a “fix”: **adding a URL parameter during fetch operations to act as a cache-buster and prevent accidental caching of the RSC payload**. However, this measure does not prevent attackers from exploiting the vulnerability by sending a request with the `Rsc` header without using a cache-buster, which mimics typical cache-poisoning attacks. Whether this attack succeeds naturally depends on **the CDN and its cache-rules**.

In theory it was exploitable, I had to be able to confirm all that with a real target, and after some research I got my first hit:
 ![](https://zhero-web-sec.github.io/images/next-cache-9.png) [](https://read.readwise.io/read/01jnjzv1r98v34b02rzmhty9xh)

## Internal header, HTTP status and error page with `x-invoke-status`

Under certain conditions - *which we will see later* - it is possible to **overwrite the status code** via the value of the `x-invoke-status` header directly provided in the request (`req.header[]`) and **invoke/return the error page** ([source](https://github.com/vercel/next.js/blob/f412c5e72a068d3667e0005f33a9ac7802634b61/packages/next/src/server/base-server.ts#L961%5D)). [](https://read.readwise.io/read/01jnjzz5kgr1gw8k3zr9bmgeyp)

I keep digging and I see that `x-invoke-status` is an **“internal” header**, so they are normally [stripped when they come from the client](https://github.com/vercel/next.js/blob/f412c5e72a068d3667e0005f33a9ac7802634b61/packages/next/src/shared/lib/constants.ts#L18):
 ![](https://zhero-web-sec.github.io/images/next-cache-12.png) [](https://read.readwise.io/read/01jnk002psmtf7hwa044hktqke)

I tried with the default configuration and included `x-invoke-status: 888` as a header, and on my first try:
 ![](https://zhero-web-sec.github.io/images/next-cache-13.png) [](https://read.readwise.io/read/01jnk01mam57fys2d7tx6v703s)

I have no doubts about the exploitability of this vector for cache-poisoning. By specifying the HTTP status code `200`, it allows compliance with most caching rules (*which typically do not initially allow caching of error codes*). This enables caching the contents of the error page, which can then be served as a response instead of the main page. [](https://read.readwise.io/read/01jnk034h1q4dv14eqtbaz2jsm)

>[!note]
>The other two vulnerabilities discussed above are particularly interesting for the same reason: the behaviors induced by adding their respective headers result in a `200` response, **which aligns with the majority of cache-rules**. [](https://read.readwise.io/read/01jnk039nmc3nh17gedgj8pgfz)

Generally, CDNs and caching systems are configured not to cache HTTP error codes. However, an attacker can specify the code `200` to align with cache rules and effectively “force” the caching of the error page, as demonstrated earlier. [](https://read.readwise.io/read/01jnk05ad6p2b0zddwvmf0k1sn)

If the `x-invoke-error` header is provided and that the error page template expected it, it is also possible to display a custom error message (*the value must be provided in json format* `{"message":"<>"}`) [](https://read.readwise.io/read/01jnk080zrxhkfqydwpqgf7993)

